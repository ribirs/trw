<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>간단한 테트리스</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      margin-top: 20px;
      font-family: sans-serif;
    }

    .container {
      display: flex;
      gap: 20px;
    }

    #next {
      display: grid;
      grid-template-columns: repeat(4, 20px);
      grid-template-rows: repeat(4, 20px);
      gap: 1px;
      background: #ccc;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(8, 30px);
      grid-template-rows: repeat(15, 30px);
      gap: 1px;
      background-color: #333;
    }

    .cell {
      width: 30px;
      height: 30px;
      background-color: #eee;
    }

    .filled {
      background-color: #999;
    }

    .red { background-color: red; }
    .yellow { background-color: yellow; }
    .blue { background-color: blue; }
    .green { background-color: green; }
    .purple { background-color: purple; }
    .cyan { background-color: cyan; }
    .orange { background-color: orange; }
  </style>
</head>
<body>
  <div class="container">
    <div>
      <h3>다음 블록</h3>
      <div id="next"></div>
    </div>
    <div class="board" id="board"></div>
  </div>

  <script>
    const boardWidth = 8;
    const boardHeight = 15;
    const board = document.getElementById("board");
    const nextDisplay = document.getElementById("next");

    // 보드 셀 생성
    const cells = [];
    for (let i = 0; i < boardWidth * boardHeight; i++) {
      const div = document.createElement("div");
      div.classList.add("cell");
      board.appendChild(div);
      cells.push(div);
    }

    // 블록 정의
    const SHAPES = [
      { shape: [[1, 1, 1], [0, 1, 0]], color: "red" },       // T
      { shape: [[1, 1, 1, 1]], color: "cyan" },              // I
      { shape: [[1, 1], [1, 1]], color: "yellow" },          // O
      { shape: [[0, 1, 1], [1, 1, 0]], color: "green" },     // S
      { shape: [[1, 1, 0], [0, 1, 1]], color: "blue" },      // Z
      { shape: [[1, 0, 0], [1, 1, 1]], color: "orange" },    // L
      { shape: [[0, 0, 1], [1, 1, 1]], color: "purple" },    // J
    ];

    function drawNextBlock(block) {
      nextDisplay.innerHTML = "";
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");
          if (block.shape[r] && block.shape[r][c]) {
            cell.classList.add(block.color);
          }
          nextDisplay.appendChild(cell);
        }
      }
    }

    // 게임 상태
    let grid = Array.from({ length: boardHeight }, () => Array(boardWidth).fill(null));
    let currentBlock = null;
    let currentX = 0;
    let currentY = 0;
    let nextBlock = getRandomBlock();

    function getRandomBlock() {
      const obj = SHAPES[Math.floor(Math.random() * SHAPES.length)];
      return {
        shape: obj.shape,
        color: obj.color
      };
    }

    function spawnBlock() {
      currentBlock = nextBlock;
      nextBlock = getRandomBlock();
      drawNextBlock(nextBlock);
      currentX = 2;
      currentY = 0;

      if (!isValidMove(currentBlock.shape, currentX, currentY)) {
        alert("게임 오버!");
        clearInterval(gameLoop);
      }
    }

    function drawBoard() {
      for (let y = 0; y < boardHeight; y++) {
        for (let x = 0; x < boardWidth; x++) {
          const cell = cells[y * boardWidth + x];
          cell.className = "cell";
          if (grid[y][x]) {
            cell.classList.add(grid[y][x]);
          }
        }
      }

      if (currentBlock) {
        const shape = currentBlock.shape;
        for (let y = 0; y < shape.length; y++) {
          for (let x = 0; x < shape[y].length; x++) {
            if (shape[y][x]) {
              const bx = currentX + x;
              const by = currentY + y;
              if (by >= 0 && by < boardHeight && bx >= 0 && bx < boardWidth) {
                cells[by * boardWidth + bx].classList.add(currentBlock.color);
              }
            }
          }
        }
      }
    }

    function isValidMove(shape, x, y) {
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (shape[r][c]) {
            const nx = x + c;
            const ny = y + r;
            if (nx < 0 || nx >= boardWidth || ny >= boardHeight) return false;
            if (ny >= 0 && grid[ny][nx]) return false;
          }
        }
      }
      return true;
    }

    function placeBlock() {
      const shape = currentBlock.shape;
      for (let y = 0; y < shape.length; y++) {
        for (let x = 0; x < shape[y].length; x++) {
          if (shape[y][x]) {
            const bx = currentX + x;
            const by = currentY + y;
            if (by >= 0) {
              grid[by][bx] = currentBlock.color;
            }
          }
        }
      }
      clearLines();
    }

    function clearLines() {
      grid = grid.filter(row => row.some(cell => !cell));
      while (grid.length < boardHeight) {
        grid.unshift(Array(boardWidth).fill(null));
      }
    }

    function moveDown() {
      if (isValidMove(currentBlock.shape, currentX, currentY + 1)) {
        currentY++;
      } else {
        placeBlock();
        spawnBlock();
      }
      drawBoard();
    }

    document.addEventListener("keydown", (e) => {
      if (!currentBlock) return;
      if (e.key === "ArrowLeft" && isValidMove(currentBlock.shape, currentX - 1, currentY)) {
        currentX--;
      } else if (e.key === "ArrowRight" && isValidMove(currentBlock.shape, currentX + 1, currentY)) {
        currentX++;
      } else if (e.key === "ArrowDown") {
        moveDown();
      } else if (e.key === "ArrowUp") {
        const rotated = rotate(currentBlock.shape);
        if (isValidMove(rotated, currentX, currentY)) {
          currentBlock.shape = rotated;
        }
      }
      drawBoard();
    });

    function rotate(shape) {
      return shape[0].map((_, i) => shape.map(row => row[i]).reverse());
    }

    // 게임 시작
    spawnBlock();
    drawBoard();
    const gameLoop = setInterval(moveDown, 700);
  </script>
</body>
</html>
