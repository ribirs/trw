<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Îπ®Í∞Ñ Í≥µÍ≥º Ï¥àÎ°ù Í≥µ</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #f0f0f0;
    }

    #ball {
      position: absolute;
      width: 50px;
      height: 50px;
      background-color: crimson;
      border-radius: 50%;
      z-index: 2;
    }

    .flame {
      position: absolute;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, orange, red, transparent);
      border-radius: 50%;
      opacity: 0.8;
      pointer-events: none;
      z-index: 1;
      animation: flicker 0.4s ease-out forwards;
    }

    .green-ball {
      position: absolute;
      width: 16px;
      height: 16px;
      background-color: green;
      border-radius: 50%;
      z-index: 1;
    }

    @keyframes flicker {
      0% {
        transform: scale(1) translateY(0);
        opacity: 1;
      }
      100% {
        transform: scale(2) translateY(20px);
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div id="ball"></div>

  <script>
    const ball = document.getElementById("ball");
    const ballSize = 50;

    let x = 100;
    let y = 100;

    let vx = 0;
    let vy = 0;

    const baseAcceleration = 0.5;
    const baseMaxSpeed = 10;
    let acceleration = baseAcceleration;
    let maxSpeed = baseMaxSpeed;
    const friction = 0.95;

    let boostMode = false;
    let lastFlameTime = 0;
    const flameInterval = 50;

    const keys = {
      ArrowUp: false,
      ArrowDown: false,
      ArrowLeft: false,
      ArrowRight: false
    };

    const greenBalls = [];
    const greenBallCount = 10;
    const greenSize = ballSize / 3;

    // Î∞©Ìñ•ÌÇ§ Ïù¥Î≤§Ìä∏
    document.addEventListener("keydown", (e) => {
      if (e.key in keys) keys[e.key] = true;

      if (e.code === "Space" && !e.repeat) {
        boostMode = !boostMode;

        if (boostMode) {
          acceleration = baseAcceleration * 2;
          maxSpeed = baseMaxSpeed * 2;
          ball.style.backgroundColor = "orange";
        } else {
          acceleration = baseAcceleration;
          maxSpeed = baseMaxSpeed;
          ball.style.backgroundColor = "crimson";
        }
      }
    });

    document.addEventListener("keyup", (e) => {
      if (e.key in keys) keys[e.key] = false;
    });

    function createFlame(x, y) {
      const flame = document.createElement("div");
      flame.className = "flame";
      flame.style.left = x + "px";
      flame.style.top = y + "px";
      document.body.appendChild(flame);
      setTimeout(() => flame.remove(), 400);
    }

    function spawnGreenBall() {
      const div = document.createElement("div");
      div.className = "green-ball";
      document.body.appendChild(div);

      return {
        el: div,
        x: Math.random() * (window.innerWidth - greenSize),
        y: Math.random() * (window.innerHeight - greenSize),
        vx: (Math.random() - 0.5) * 3, // ÎäêÎ¶¨Í≤å ÏõÄÏßÅÏûÑ
        vy: (Math.random() - 0.5) * 3,
      };
    }

    function respawnGreenBall(gb) {
      gb.x = Math.random() * (window.innerWidth - greenSize);
      gb.y = Math.random() * (window.innerHeight - greenSize);
      gb.vx = (Math.random() - 0.5) * 3;
      gb.vy = (Math.random() - 0.5) * 3;
    }

    function checkCollision(ax, ay, asize, bx, by, bsize) {
      const dx = ax + asize / 2 - (bx + bsize / 2);
      const dy = ay + asize / 2 - (by + bsize / 2);
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < (asize + bsize) / 2;
    }

    // Ï¥àÎ°ù Í≥µ Ï¥àÍ∏∞Ìôî
    for (let i = 0; i < greenBallCount; i++) {
      const gb = spawnGreenBall();
      greenBalls.push(gb);
    }

    function update(timestamp) {
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;

      // üî¥ Îπ®Í∞Ñ Í≥µ Ïù¥Îèô
      if (keys.ArrowUp) vy -= acceleration;
      if (keys.ArrowDown) vy += acceleration;
      if (keys.ArrowLeft) vx -= acceleration;
      if (keys.ArrowRight) vx += acceleration;

      vx = Math.max(-maxSpeed, Math.min(maxSpeed, vx));
      vy = Math.max(-maxSpeed, Math.min(maxSpeed, vy));

      x += vx;
      y += vy;

      if (x + ballSize < 0) x = screenWidth;
      else if (x > screenWidth) x = -ballSize;

      if (y + ballSize < 0) y = screenHeight;
      else if (y > screenHeight) y = -ballSize;

      vx *= friction;
      vy *= friction;

      ball.style.left = x + "px";
      ball.style.top = y + "px";

      // üî• Î∂àÍΩÉ
      if (boostMode && timestamp - lastFlameTime > flameInterval) {
        lastFlameTime = timestamp;
        createFlame(x + ballSize / 2 - 10, y + ballSize / 2);
      }

      // üü¢ Ï¥àÎ°ù Í≥µÎì§ ÏóÖÎç∞Ïù¥Ìä∏
      for (const gb of greenBalls) {
        gb.x += gb.vx;
        gb.y += gb.vy;

        // ÌôîÎ©¥ ÎÑòÏñ¥Í∞ÄÎ©¥ Î∞òÎåÄÏ™Ω
        if (gb.x + greenSize < 0) gb.x = screenWidth;
        else if (gb.x > screenWidth) gb.x = -greenSize;
        if (gb.y + greenSize < 0) gb.y = screenHeight;
        else if (gb.y > screenHeight) gb.y = -greenSize;

        // ÏúÑÏπò Ï†ÅÏö©
        gb.el.style.left = gb.x + "px";
        gb.el.style.top = gb.y + "px";

        // Ï∂©Îèå Ï≤¥ÌÅ¨
        if (checkCollision(x, y, ballSize, gb.x, gb.y, greenSize)) {
          respawnGreenBall(gb);
        }
      }

      requestAnimationFrame(update);
    }

    requestAnimationFrame(update);
  </script>
</body>
</html>
